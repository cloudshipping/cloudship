//! Traits for implementing the SMTP server logic.
//!
//! There is two traits here plus the SASL traits for authentication. The
//! `Protocol` trait is used to perform general processing for a client
//! connection. The `MailTransaction` trait is used for processing a single
//! mail transaction.
//!
//! All the methods in these traits work the same: They take an owned `self`
//! plus perhaps a bunch of additional arguments and return an optional new
//! owned `Self`. By returning `None` they indicate failure and the end of
//! processing. By returning `Some(Self)`, they indicate continued processing
//! using the returned state machine.
//!
//! Most methods additionally allow to delay their decision whether to
//! continue or not. The return type of these methods is
//! `Hesitant<Self>` with the three options `Hesitant::Continue(Self)`,
//! `Hesitant::Wait(Self)` and `Hesitant::Stop`. For defering, you will
//! receive a `Notifier` in `Protocol::create()` that you can use to wake
//! up the underlying state machine later.
//!
//! Each such method has a companion method prefixed with `continue_` which
//! is called if the underlying state machine has been woken up. Note that
//! such a wake-up may be spurious and doesn't necessarily mean that the
//! notifer was actually called by your code. All continuation methods have
//! default implementations that panic to safe you some work if you don't
//! actually defer certain methods.
//!
//! You can be sure that after a deferring response the continuation method
//! is the next method called.
//!
use openssl::ssl::SslContext;
use openssl::x509::X509;
use rotor::Notifier;
use super::super::syntax;
use super::ReplyBuf;

/// A trait for context types supporting the SMTP server.
///
pub trait Context: Sized {
    fn ssl_context(&self) -> SslContext;
    fn hostname(&self) -> &[u8];
    fn systemname(&self) -> &[u8];
    fn message_size_limit(&self) -> u64;
}


/// The return type for deferable methods.
///
#[derive(Debug)]
pub enum Hesitant<M> {
    Continue(M),
    Defer(M),
    Stop
}

/// The trait of the SMTP server session.
///
pub trait Protocol: Sized {
    type Context: Context;
    type Mail: MailTransaction;

    /// Start the protocol.
    fn create(context: &Self::Context, notifier: Notifier) -> Option<Self>;

    /// A HELO or EHLO command has been received.
    ///
    /// The domain passed in by the client as part of the hello is given
    /// in *domain*. The reply to the hello is generated by underlying
    /// machine. All you can do is stop processing by returning `Stop`
    /// either right away or later.
    ///
    fn hello(self, domain: syntax::MailboxDomain) -> Hesitant<Self>;
    fn continue_hello(self) -> Hesitant<Self> {
        unreachable!()
    }

    /// A TLS handshake has finished.
    ///
    /// If the client presented a certificate, it is in *peer_cert*. This
    /// method is here to allow you to decide whether to continue with the
    /// session with this certificate (or its lack).
    ///
    fn starttls(self, peer_cert: Option<X509>) -> Hesitant<Self>;
    fn continue_starttls(self) -> Hesitant<Self> {
        unreachable!()
    }

    /// Creates a new mail transaction for this session.
    ///
    fn mail(&self) -> Self::Mail;

    /// A VRFY command was received.
    ///
    fn verify(self, what: syntax::Word, params: syntax::VrfyParameters,
              send: ReplyBuf) -> Hesitant<Self>;
    fn continue_verify(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }

    /// An EXPN command has been received.
    ///
    fn expand(self, what: syntax::Word, params: syntax::ExpnParameters,
              send: ReplyBuf) -> Hesitant<Self>;
    fn continue_expand(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }

    /// A HELP command has been received.
    ///
    fn help(self, what: Option<syntax::Word>, send: ReplyBuf)
            -> Hesitant<Self>;
    fn continue_help(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }
}


/// The trait for a single mail transaction.
///
pub trait MailTransaction: Sized {

    //--- Mail transactions

    /// A MAIL command has been received.
    ///
    /// The next method called is either `rcpt()` or `rset()`.
    ///
    /// It is your responsibility to send the correct reply using the
    /// reply buffer provided in *send*. You will have to provide the
    /// reply even if you return `None` to indicate that you want to
    /// abort this transaction.
    ///
    fn mail(self, path: syntax::ReversePath, params: syntax::MailParameters,
            send: ReplyBuf) -> Hesitant<Self>;
    fn continue_mail(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }

    /// A RCPT command has been received.
    ///
    /// The next method is either `rcpt()`, `data()` or `rset()`.
    ///
    /// It is your responsibility to send the correct reply using the
    /// reply buffer provided in *send*. You will have to provide the
    /// reply even if you return `None` to indicate that you want to
    /// abort this transaction.
    ///
    fn recipient(self, path: syntax::RcptPath,
                  params: syntax::RcptParameters, send: ReplyBuf)
                  -> Hesitant<Self>;
    fn continue_recipient(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }

    /// A DATA (or BDAT) command has been received.
    ///
    /// The underlying machine takes care of the actual data handling. If
    /// you return in the affirmative here, `chunk()` is called next.
    ///
    fn data(self) -> Hesitant<Self>;
    fn continue_data(self) -> Hesitant<Self> {
        unreachable!()
    }

    /// A chunk of message data has been received.
    ///
    /// There is no defering or cancelling here. You will have to process
    /// the chunk of data in *data* or loose it.
    ///
    fn chunk(&mut self, data: &[u8]);

    /// The last chunk was received.
    ///
    /// Once you do a final affirmative return or a none-return, the
    /// transaction is over.
    ///
    fn complete(self, send: ReplyBuf) -> Hesitant<Self>;
    fn continue_complete(self, send: ReplyBuf) -> Hesitant<Self> {
        let _ = send;
        unreachable!()
    }

    /// A RSET command was received.
    ///
    /// Once you do a final affirmative return or a none-return, the
    /// transaction is over.
    ///
    fn reset(self) -> Hesitant<Self>;
    fn continue_reset(self) -> Hesitant<Self> {
        unreachable!()
    }
}
